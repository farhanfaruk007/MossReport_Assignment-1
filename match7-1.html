<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/2/20201125_Lab01_02_-_MST_SUSHMITA_KHATUN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/13/22301549_Iftekher_Uddin_Rafi_Assignment01_Fall_2024_-_IFTEKHER_UDDIN_RAFI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22301549_IftekherUddinRafi_Lab01_Fall2024.py.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m_C9fmLl4ogdDV69pJCOWDOO0-s5l-w3
"""

<a name="1"></a><font color="#00FF00"><a href="match7-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_23.gif"/></a>

f = open("22301549_Iftekher Uddin Rafi_CSE422_13_Lab_Assignment01_InputFile_Fall2024.py.txt", mode="r")
lines = f.readlines()
f.close()

straight_line_distance = {}
city_connections = {}

for line in lines:
    line = line.strip()
    parts = line.split(" ")
    city, distance = parts[0], parts[1]
    straight_line_distance[city] = distance

    current_city = parts[0]
    neighbors = [[parts[i], int(parts[i + 1])] for i in range(2, len(parts), 2)]

    city_connections[current_city] = neighbors

def find_shortest_path(start, destination):
    global city_connections, straight_line_distance
    queue = []
    queue.append([0, start])
</font><a name="0"></a><font color="#FF0000"><a href="match7-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_42.gif"/></a>

    path_costs = {start: 0}
    heuristic_costs = {start: straight_line_distance[start]}
    parents = {}

    while queue:
        sorted_queue = sorted(queue)
        current_node = sorted_queue[0][1]
        queue.pop(0)

        for neighbor, distance in city_connections[current_node]:
            explore_neighbor(neighbor, distance, current_node, path_costs, heuristic_costs, parents, queue)

        optimal_path = []
        if current_node == destination:
            optimal_path.append(destination)
            while current_node in parents:
                optimal_path.append(parents[current_node])
                current_node = parents[current_node]
            return optimal_path

def explore_neighbor(neighbor, distance, current, path_costs, heuristic_costs, parents, queue):
    total_cost = path_costs[current] + distance
    if neighbor in path_costs:
        pass
    if (neighbor not in path_costs) or (total_cost &lt; path_costs[neighbor]):
        parents[neighbor] = current
        path_costs[neighbor] = total_cost
        straight_line_cost = int(straight_line_distance[neighbor])
        heuristic_costs[neighbor] = path_costs[neighbor] + straight_line_cost
        queue.append([heuristic_costs[neighbor], neighbor])

start_city = "Arad"
destination_city = 'Bucharest'

path_result = find_shortest_path(start_city, destination_city)
path_result = path_result[::-1]

path_length = len(path_result)
user_input = input("Enter a city name: ")#write Arad as starting city
</font>
if user_input == start_city:
    total_distance = 0
    print("Path: ", end="")
    for city in path_result:
        print(city, "-&gt;", end="") if city != path_result[-1] else print(city)
<a name="2"></a><font color="#0000FF"><a href="match7-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

    for i in range(path_length - 1):
        for city_name in city_connections:
            if path_result[i] == city_name:
                for neighbor in city_connections[city_name]:
                    if neighbor[0] == path_result[i + 1]:
                        total_distance += neighbor[1]
    print("Total distance: ", total_distance, "km")
else:
    print("NO PATH FOUND")
</font>
"""# New Section"""</pre>
</body>
</html>
