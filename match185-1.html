<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/2/21201199_lab1_sec2_-_MD._ZAHIDUL_HASAN_ZIAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/9/21201480_hasan_21201480_-_Hasan_Mahmud.py<p></p><pre>
# -*- coding: utf-8 -*-
"""Hasan_21201480.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RleQ5RthfIdTiJ7uw8UIHKij9fD2o2sJ
"""

import heapq

import heapq

# Taking input
input_file = open("/content/input.txt", 'r')

# Line management
lines = input_file.readlines()
map = {}
heuristic = {}

<a name="0"></a><font color="#FF0000"><a href="match185-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

for line in lines:
    x = line.split()
    city_name = x[0]
    n = len(x)
    heuristic[city_name] = int(x[1])
    for i in range(2, n, 2):  # neighbor and distance
        if city_name not in map:
            map[city_name] = {}
        map[city_name][x[i]] = int(x[i + 1])
</font>
# A* Search
def create_path(startnode, goalnode):
    new_path = []
    path = []
    while True:
        if goalnode not in startnode:
            break
        new_path.append(goalnode)
        goalnode = startnode[goalnode]
    new_path.append(goalnode)
    for i in range(len(new_path) - 1, -1, -1):
        path += [new_path[i]]
    return path

def A_star_Search(map, heuristic, start, goal):
    open_list = []
    closed_list = []
<a name="2"></a><font color="#0000FF"><a href="match185-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_5.gif"/></a>

    g = {start: 0}
    startnode = {}
    f_cost = heuristic[start] + g[start]
    heapq.heappush(open_list, (f_cost, start))
    while open_list:
        m = heapq.heappop(open_list)
</font>        if m[1] == goal:
            dist = g[goal]
            return create_path(startnode, goal), dist
        closed_list.append(m[1])
        for neighbor, distance in map[m[1]].items():
            if neighbor in closed_list:
                continue
            g_cost = distance + g[m[1]]
            if neighbor in [item[1] for item in open_list] and g_cost &lt; g[neighbor]:
                open_list = [(f, n) for f, n in open_list if n != neighbor]
                heapq.heapify(open_list)
            if neighbor in closed_list and g_cost &lt; g[neighbor]:
                closed_list.remove(neighbor)
            if neighbor not in [item[1] for item in open_list] and neighbor not in closed_list:
                g[neighbor] = g_cost
                f_cost = g_cost + heuristic[neighbor]
                heapq.heappush(open_list, (f_cost, neighbor))
                startnode[neighbor] = m[1]
<a name="1"></a><font color="#00FF00"><a href="match185-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    return None, -1

# Output

start = input("Enter the starting point: ")
goalnode = input("Enter your destination: ")

function_call, dist = A_star_Search(map, heuristic, start, goalnode)

if function_call is None:
    print("No path found")
else:
    print("Path: ", end="")
</font>    for i in range(len(function_call)):
        if i == len(function_call) - 1:
            print(function_call[i])
        else:
            print(function_call[i], "--&gt; ", end="")
    print("Total Distance:", dist, "Km")</pre>
</body>
</html>
