<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101802_AhnafWarid_CSE422_07_Assignment01_Fall2024_-_AHNAF_WARID.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/17/21201645_-_ABIDA_RAHMAN_CSE422_17_Assignment01_Fall2024.py<p></p><pre>
import heapq


def read_graph(input_file):
    graph = {}
    heuristics = {}
    with open("/Users/abidarahman/PycharmProjects/pythonProject/422 (final)/input", 'r') as file:
        for x in file:
            variable = x.strip().split()
            Node = variable[0]
            h = int(variable[1])
            nxt_nodes = {variable[i]: int(variable[i + 1]) for i in range(2, len(variable), 2)}
            graph[Node] = nxt_nodes
            heuristics[Node] = h
    return graph, heuristics

##The function i.e read_graph(input_file) reads a graph and heuristics
#It initializes an empty dictionary graph for the adjacency list of nodes
#following heuristic values


def a_star_search(Graph, Heuristics, Start, Goal):
    mod = []
    heapq.heappush(mod, (Heuristics[Start], Start))
    prev = {}
    g_cost = {Node: float('inf') for Node in Graph}
    g_cost[Start] = 0
    f_cost = {Node: float('inf') for Node in Graph}
    f_cost[Start] = Heuristics[Start]

    while mod:
        _, Current_Node = heapq.heappop(mod)
<a name="1"></a><font color="#00FF00"><a href="match167-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

        if Current_Node == Goal:
            return reconstruct_path(Prev, Current_Node), g_cost[Goal]

        for child, distance in Graph[Current_Node].items():
            possible_g_cost = g_cost[Current_Node] + distance
            if possible_g_cost &lt; g_cost[child]:
</font><a name="0"></a><font color="#FF0000"><a href="match167-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_19.gif"/></a>

                prev[child] = Current_Node
                g_cost[child] = possible_g_cost
                f_cost[child] = g_cost[child] + Heuristics[child]
                heapq.heappush(mod, (f_cost[child], child))

    return None, None


def reconstruct_path(Prev, Current_Node):
    path = []
    while Current_Node in Prev:
        path.append(Current_Node)
        cur = Prev[Current_Node]
    path.append(Current_Node)
</font>    return path[::-1]


def result():
    input_file = '/Users/abidarahman/PycharmProjects/pythonProject/422 (final)/1234.py'

<a name="2"></a><font color="#0000FF"><a href="match167-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

    Graph, Heuristics = read_graph(input_file)

    Start_Node = input("Enter the starting city: ")
    Goal = input("Enter the destination city: ")

    Path, Total_distance = a_star_search(Graph, Heuristics, Start, Goal)

    if Path:
        print("Optimal path:", " -&gt; ".join(Path))
        print("Total distance:", Total_distance)
</font>    else:
        print("No path found.")


result()
</pre>
</body>
</html>
