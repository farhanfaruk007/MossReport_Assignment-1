<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/8/21301035_omarnasif_section08_-_OMAR_NASIF_CHOWDHURY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/8/21301035_omarnasif_section08_-_OMAR_NASIF_CHOWDHURY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301035_OmarNasif_Section08

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h4jdwX_oiCzvSJT8QTNxRfYUS3Q8neOS
"""

from typing import final
with open('21301035.txt', 'r', encoding='utf-8-sig') as file:
    input_files = file.readlines()
    #print(input_files)
h_value={}
var0=0
g={}
nested={}
priority_queue={}
starting_node="A"
goal_node="Z"
total_distance= 0
visited_nodes=[]
final_path=[]
distance= 0
temporary=""  # After popping the path will be recorded
cities = {'Arad': 'A', 'Neamt': 'F','Bucharest': 'Z', 'Oradea': 'B', 'Craiova': 'S', 'Eforie': 'T', 'Pitesti': 'P','Fagaras': 'O', 'Timisoara': 'C','Dobreta': 'V','Urziceni': 'D',
           'Hirsova': 'N', 'Vaslui': 'H','lasi': 'Q', 'Zerind': 'E','Lugoj': 'G', 'Mehadia': 'L', 'RimnicuVilcea': 'R',
              'Giurgiu':'I','Sibiu':'J'}   # Declaring a Dictanary...
#print(cities)
#task 1
# Dict1 = {}
# for i, j in h_value.items():
#     var2 = i.replace('\ufeff', '')
#     Dict1[var2] = j


for index in range(len(input_files)):
  input_files[index]=input_files[index].strip() #for removing /n every line
  var = (input_files[index]).split(" ")    # Splitting the lines with respect to space
  h_value[cities[var[0]]]=int(var[1])     #appending into dict   converting


<a name="1"></a><font color="#00FF00"><a href="match183-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_7.gif"/></a>

  for i in range(2,len(var)-1):
    if i%2==0:
      nested[cities[var[i]]]= int(var[i+1])
</font>      g[cities[var[0]]]=nested
  nested={}   #graph in g , work done thats why nested empty

#print(g)
#print(h_value)

while temporary!= goal_node :
  if temporary=="":
    priority_queue[starting_node]=h_value[starting_node]
    #print(priority_queue)
    temporary=priority_queue.popitem()[0]
    final_path.append(temporary)
    #print(temporary)
    #print(priority_queue)
<a name="2"></a><font color="#0000FF"><a href="match183-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

  else:
    for i in g[temporary]:  #g[temporary ]
      if  i not in visited_nodes and i not in priority_queue:
        priority_queue[i] = h_value[i] + g[temporary][i]+distance
</font><a name="0"></a><font color="#FF0000"><a href="match183-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_16.gif"/></a>

        visited_nodes.append(i)
    total_distance+=distance
    priority_queue = dict(sorted(priority_queue.items(), key=lambda item: item[1]))
    distance=g[temporary][list(priority_queue.keys())[0]]
    distance=int(distance)
    temporary = list(priority_queue.keys())[0]
    priority_queue.pop(temporary)
    final_path.append(temporary)
</font>#print(final_path)
#print(temporary)
last_node_distance=(g[final_path[-2]][temporary])
print(total_distance+last_node_distance, end= " Km \n" )

swapped_cities = {v: k for k, v in cities.items()}
if "Z" not in final_path:
  print(" No Path Found : ")
#print(swapped_cities)
else:
  for j in final_path:
    if var0!= len(final_path)-1:
      print(swapped_cities[j], end=" &gt;&gt; ")
      var0+=1
    else:
      print(swapped_cities[j])

</pre>
</body>
</html>
