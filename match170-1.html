<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/15/24241319_s_m_mahidur_rahman_cse422_15_lab_assignment_01_fall_2024_-_S_M_MAHIDUR_RAHMAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/16/24141248_golamrahi_sec16_422_lab1_-_GOLAM_MOHAMMAD_RAHI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""golamrahi_24141248_sec16_422

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TBGrS3S2iOqgMNXPKJBVSCpoCzGD33Yq
"""

import heapq



def read_graph(ifile):
    grph = {}
    estimates = {}


    with open(ifile, 'r') as file:
        line = file.readline()
        while line:
            parts = line.split()
            node = parts[0]
            estimate = int(parts[1])
            estimates[node] = estimate
            neighbors = {}
            i = 2
            while i &lt; len(parts):
                neighbor = parts[i]
                distance = int(parts[i + 1])
                neighbors[neighbor] = distance
                i += 2
            grph[node] = neighbors
<a name="1"></a><font color="#00FF00"><a href="match170-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

            line = file.readline()

    return grph, estimates



def a_star_search(grph, estimates, source, target):
    open_set = []
    heapq.heappush(open_set, (0 + estimates[source], 0, source))
    previous_node = {}
    distance_from_start = {node: float('inf') for node in grph}
    distance_from_start[source] = 0
</font>

    for _ in iter(int, 1):  # infinite loop, breaking when priority queue is empty
        if not open_set:
            break
        _, current_g, current = heapq.heappop(open_set)

        if current == target:
            path = []
            while current in previous_node:
                path.append(current)
                current = previous_node[current]
            path.append(source)
            path.reverse()
            return path, current_g

        neighbors = list(grph[current].items())
        index = 0
        while index &lt; len(neighbors):
            neighbor, distance = neighbors[index]
<a name="2"></a><font color="#0000FF"><a href="match170-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

            tentative_g_score = current_g + distance
            if tentative_g_score &lt; distance_from_start[neighbor]:
                previous_node[neighbor] = current
                distance_from_start[neighbor] = tentative_g_score
                f_score = tentative_g_score + estimates[neighbor]
</font>                heapq.heappush(open_set, (f_score, tentative_g_score, neighbor))
            index += 1

<a name="0"></a><font color="#FF0000"><a href="match170-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

    return None, None



def main():
    ifile = '/content/drive/MyDrive/Input file (1).txt'

    grph, estimates = read_graph(ifile)
    source = input('Start node: ').strip()

    target = input('Destination: ').strip()
    path, total_distance = a_star_search(grph, estimates, source, target)

    if path:
        print(f'Path: {" -&gt; ".join(path)}')
        print(f'Total distance: {total_distance} km')


    else:
        print('NO PATH FOUND')


if __name__ == '__main__':
</font>    main()</pre>
</body>
</html>
