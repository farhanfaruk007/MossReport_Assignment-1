<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/10/24341205_cse422_10_labassignment1_shuaib_zulkarnain.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/10/24341205_cse422_10_labassignment1_shuaib_zulkarnain.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341205_CSE422_10_LabAssignment1 - SHUAIB ZULKARNAIN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VOk7OEo4_ktjK9uzf8qtP9lGjQrGzehP
"""

# TASK 1    (DONE)
import heapq

graph = {}
hx = {}


with open('/content/sample_data/input.txt', 'r') as file:       # avoiding hard code
<a name="1"></a><font color="#00FF00"><a href="match48-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_13.gif"/></a>

    for line in file:

        x = line.split()
        hx[x[0]] = int(x[1])

        for j in range(2, len(x) - 1, 2):
            if x[0] not in graph:
                graph[x[0]] = {x[j]: int(x[j + 1])}

            else:
                graph[x[0]].update({x[j]: int(x[j + 1])})
</font>                # graph[x[0]][x[j]] = int(x[j + 1])

# print(graph)
# print(hx)

<a name="0"></a><font color="#FF0000"><a href="match48-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_28.gif"/></a>

def a_star_search(start, goal, graph, hx):
    queue = []
    heapq.heappush(queue, (hx[start], 0, start))
    parent = {}
    path_cost = {node: float('inf') for node in graph}      # key node: cost = inf
    path_cost[start] = 0

    # while queue is not None:
    # while len(queue) != 0:
    while queue:
        heuristic, cost, node = heapq.heappop(queue)        # unpacking the tuple

        if node == goal:
            path = []

            while node in parent:
                path.append(node)
                node = parent[node]

            path.append(start)
            path.reverse()
            return path, path_cost[goal]

        if node in graph:

            for neighbor, n_cost in graph[node].items():
                graph_cost = cost + n_cost

                if graph_cost &lt; path_cost[neighbor]:        # better path found &amp; update
                    path_cost[neighbor] = graph_cost
                    parent[neighbor] = node

                    total = graph_cost + hx[neighbor]       # sum of path cost and heuristic
                    heapq.heappush(queue, (total, graph_cost, neighbor))

    return None, float('inf')


path, path_cost = a_star_search('Arad', 'Bucharest', graph, hx)
</font>
if path_cost == float('inf'):
    print("No path found")

else:
    z = ' -&gt; '.join(path)
    print(f"Path: {z}")

print("Total Distance:", path_cost, 'km')

#uninformed search -&gt; BFS(cant work for wighted graph), DFS, Uniform Cost Search(solve BFS's limitation)
# UCS -&gt; works using actual cost(kinda like dijkstra)..almost like A* but without h(X)
# UCS can also fall into infinite loop
# actual cost -&gt; cost from start node

# visited array - to handle bi paths like A-&gt;B and B-&gt;A given
# parent dictionary - a) to find the path b) ???
# dictionary - key(parent) : value(childs)
# we can use built in fuction like heap queue

input_file = open("/content/sample_data/input.txt", "r")
# n = 20
graph = {}  # dictionary for graph
hx = []     # list for heuristic values

for i in range(20):
    print(input_file.readline())




# with open("your_file.txt", "r") as file:
#     for line in file:
#         # Process each line here
#         print(line.strip())  # Example: printing each line





# MAKE A LIST FIRST FOR INPUT
# PUT THEM IN THE DICTIONARY like # {a: [(b, cost), ...]}
# How to handle h(X)


# graph = {}
# def city(city, hx, *args):
#     global graph
#     print(city, hx, args)


# for i in range(n):
#     x = input_file.readline().strip().split()
#     city(x[0], x[1], (j for j in range(n)))

import heapq
graph = {}  # dictionary for graph
h = []

with open('/content/sample_data/input.txt', 'r') as file:
    for line in file:
        x = line.split()
        lst = []

        h.append((x[0], x[1]))

        for j in range(2, len(x), 2):
            lst.append((x[j], x[j+1]))

        # lst.insert(0, x[1])
        graph[x[0]] = lst
        lst = []

    print(graph)

hx = {}     # for heuristic

for ind in range((len(h))):
    hx[h[ind][0]] = h[ind][1]

print(hx)

# def heuristic(city, hx):
#     return hx[city]

def a_star_search(start, goal, graph, hx):

    queue = []
    visited = set()
    parent = {}
    heapq.heapify(queue)
    heapq.heappush(queue, start)
    # queue = set(start)
    # visited = set()

    while len(queue) != 0 or heapq.heappop(queue) != goal:
        x = heapq.heappop(queue)
        for (n, cost) in graph:
            heapq.heappush(queue, n)
            parent[n] = x

        # if x not in visited:
        #     visited.add(x)

        pass



    pass

x = 'Arad 366 Zerind 75 Timisoara 118 Sibiu 140'
y = x.split()
print(y)
open_set = set(start_node)
closed_set= set()</pre>
</body>
</html>
