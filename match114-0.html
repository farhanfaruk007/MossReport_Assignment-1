<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/18/20301384_sayeed_bin_miraj_cse422_18_assignment01_fall2024_-_SAYEED_BIN_MIRAJ.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/18/20301384_sayeed_bin_miraj_cse422_18_assignment01_fall2024_-_SAYEED_BIN_MIRAJ.py<p></p><pre>
# -*- coding: utf-8 -*-
"""20301384_Sayeed_Bin_Miraj_CSE422_18_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PiTkkvDuBwx_A5oZrEaRkBdnZahGHtQg
"""

<a name="0"></a><font color="#FF0000"><a href="match114-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_20.gif"/></a>

from queue import PriorityQueue

def a_star_search(graph, start_node, target_node):
    node_list = [(0, start_node)]  # Fringe list to hold nodes to be explored
    parent_map = {}  # Tracks the parent of each visited node for path reconstruction

    # Initialize path costs from the start node to all nodes as infinity
    g_cost = {node: float('inf') for node in graph}
    g_cost[start_node] = 0  # Cost from start to itself is zero

    # Initialize estimated total cost (g(n) + h(n)) as infinity
    f_cost = {node: float('inf') for node in graph}
    f_cost[start_node] = graph[start_node]['heuristic']

    while node_list:  # Loop until all nodes in the open list are processed
        # Pop the node with the smallest f_cost from the open list
        _, current_node = node_list.pop(0)
</font>
        # If the target node is reached, reconstruct and return the path
        if current_node == target_node:
            path = []

            while current_node in parent_map:  # Backtracking the path using the parent_map
                path.append(current_node)
                current_node = parent_map[current_node]

            path.append(start_node)
<a name="3"></a><font color="#00FFFF"><a href="match114-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_8.gif"/></a>

            return f"Path: {' -&gt; '.join(reversed(path))}\nTotal Distance: {g_cost[target_node]} km"

        # Visit each neighbor of the current node
        for neighbor, cost in graph[current_node]['neighbors'].items():
            tentative_g_cost = g_cost[current_node] + cost

            # If a shorter path to the neighbor is found
            if tentative_g_cost &lt; g_cost[neighbor]:
</font>                parent_map[neighbor] = current_node
                g_cost[neighbor] = tentative_g_cost
                f_cost[neighbor] = g_cost[neighbor] + graph[neighbor]['heuristic']

                # Add the neighbor to the open list
<a name="2"></a><font color="#0000FF"><a href="match114-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_9.gif"/></a>

                node_list.append((f_cost[neighbor], neighbor))

    return "NO PATH FOUND"

def load_graph(file_path):
    graph_data = {}  # Dictionary to store the graph structure

    with open(file_path, 'r') as file:
        for line in file:
            parts = line.split()  # Split each line to extract node and heuristic information
            node_name = parts[0]
</font>            heuristic_value = int(parts[1])
            neighbors_info = {}

            # Parse neighbor information
            for i in range(2, len(parts), 2):  # Neighbors start from index 2
<a name="1"></a><font color="#00FF00"><a href="match114-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

                neighbor_name = parts[i]
                distance = int(parts[i + 1])
                neighbors_info[neighbor_name] = distance

            graph_data[node_name] = {'heuristic': heuristic_value, 'neighbors': neighbors_info}

    return graph_data

def main():
    # Load the graph from the input file
    graph = load_graph('/content/Input file.txt')
    start = input("Enter the starting node: ")
</font>    destination = input("Enter the destination node: ")

    # Perform A* search and display the result
    print(a_star_search(graph, start, destination))

if __name__ == "__main__":
    main()</pre>
</body>
</html>
