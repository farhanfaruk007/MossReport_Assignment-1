<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/6/21301401_mahmudferdous_cse422_06_assignment01_fall2024_py_-_MAHMUD_FERDOUS.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/6/21301401_mahmudferdous_cse422_06_assignment01_fall2024_py_-_MAHMUD_FERDOUS.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301401_MahmudFerdous_CSE422_06_Assignment01_Fall2024.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/167--t4VOz6DRe-7gfeew9s5BLwuqXWdq
"""

from google.colab import drive
drive.mount('/content/drive')

# Input reading

<a name="0"></a><font color="#FF0000"><a href="match74-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_35.gif"/></a>

inp_figure = open("/content/drive/MyDrive/422 A1/input.txt","r")


def hueristic_val(inp_figure):
    val_of_hueristic = {}

    for places_name in inp_figure:
        new_list = places_name.strip().split()
        val_of_hueristic[new_list[0]] = int(new_list[1])
    return val_of_hueristic

val_of_hueristic = hueristic_val(inp_figure)

# Expecting heuristic list
# heuristic = {'Arad': 366, 'Craiova': 160, 'Eforie': 161, 'Fagaras': 176, 'Giurgiu': 77, 'Mehadia': 241, 'Neamt': 234, 'Sibiu': 253, 'Oradea': 380, 'Pitesti': 100, 'RimnicuVilcea': 193, 'Dobreta': 242, 'Hirsova': 151, 'lasi': 226, 'Lugoj': 244, 'Timisoara': 329, 'Urziceni': 80, 'Vaslui': 199, 'Zerind': 374, 'Bucharest': 0}

#Function making to generates an adjacency list.


inp_figure = open("/content/drive/MyDrive/422 A1/input.txt", "r")

adjacency_value = {}
other_value_of_adjacency = {}



for all_cities in inp_figure:
    new_list = all_cities.strip().split()


    checking_list_size = len(new_list)


    for name in range(2, checking_list_size, 2):
        other_value_of_adjacency[new_list[name]] = int(new_list[name+1])


    adjacency_value[new_list[0]] = other_value_of_adjacency # all city and city's distance with road_distance
    other_value_of_adjacency = {}



#print(adjacency_value)

#adjacency_value = {'Arad': {'Zerind': 75, 'Timisoara': 118, 'Sibiu': 140}, 'Craiova': {'Dobreta': 120, 'RimnicuVilcea': 146, 'Pitesti': 138}, 'Eforie': {'Hirsova': 86}, 'Fagaras': {'Sibiu': 99, 'Bucharest': 211}, 'Giurgiu': {'Bucharest': 90}, 'Mehadia': {'Lugoj': 70, 'Dobreta': 75}, 'Neamt': {'lasi': 87}, 'Sibiu': {'Oradea': 151, 'Arad': 140, 'RimnicuVilcea': 80, 'Fagaras': 99}, 'Oradea': {'Zerind': 71, 'Sibiu': 151}, 'Pitesti': {'RimnicuVilcea': 97, 'Craiova': 138, 'Bucharest': 101}, 'RimnicuVilcea': {'Sibiu': 80, 'Craiova': 146, 'Pitesti': 97}, 'Dobreta': {'Mehadia': 75, 'Craiova': 120}, 'Hirsova': {'Urziceni': 98, 'Eforie': 86}, 'lasi': {'Vaslui': 92, 'Neamt': 87}, 'Lugoj': {'Timisoara': 111, 'Mehadia': 70}, 'Timisoara': {'Arad': 118, 'Lugoj': 111}, 'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142}, 'Vaslui': {'Urziceni': 142, 'lasi': 92}, 'Zerind': {'Oradea': 71, 'Arad': 75}, 'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Giurgiu': 90, 'Urziceni': 85}}

#  A star algorithm

import heapq # using python built in function for making tree

def A_star(start, goal, adjacency_value, heuristic):
    name_of_cities = [] # starting node
    heapq.heappush(name_of_cities, (0, start)) # successfully create the tree
    #print(name_of_cities)


    # create root and travse all data and create a new dictionaty with costing
    first_cname = {}

    distance = {}

    first_cname[start] = None
</font>
    distance[start] = 0
    #print(distance)


# adding the city name into a tree
    while name_of_cities:
        building_tree = heapq.heappop(name_of_cities)[1] # all new route has selected
        #print(building_tree)
        if building_tree == goal:
            break           # if the last value loop is not needed anymore


        for city_name in adjacency_value[building_tree]:

            #print(distance[building_tree])

            upgrader_distance = distance[building_tree] + adjacency_value[building_tree][city_name]    # calculating g(n) which is necessary for A* algorithm

            if city_name not in distance or upgrader_distance &lt; distance[city_name]:

                distance[city_name] = upgrader_distance
                priority_list = upgrader_distance + heuristic[city_name]     # Taking helps of iteration to calculate F(n)

<a name="1"></a><font color="#00FF00"><a href="match74-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

                heapq.heappush(name_of_cities, (priority_list, city_name))
                first_cname[city_name] = building_tree

    return first_cname, distance # The obtain value for further steps

# result finding


def result(first_cname, distance):

    calculated_distance_value = []
    calculated_distance_value.append(goal)
    city = goal

    while city != start:
</font>        city = first_cname[city]
        calculated_distance_value.append(city)

    calculated_distance_value.reverse()

# Path and distance calculating
    if len(calculated_distance_value) == 0:
        print("NO PATH FOUND")
    else:

        path_str = " --&gt; ".join(calculated_distance_value)
        print(f"Path: {path_str}")

        print(f"Total distance: {distance[goal]} km")

#Input inserting and printing the possible output

<a name="2"></a><font color="#0000FF"><a href="match74-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

start = input("Start node: ")
goal = input("Goal node: ")

# start = 'Arad'
# goal = 'Bucharest'

if start and goal not in val_of_hueristic:
    print("There is no starting point or destination, or it's possible that a naming mistake has occurred.....")

else:
    first_cname, distance = A_star(start, goal, adjacency_value, val_of_hueristic)
    result(first_cname, distance)</font></pre>
</body>
</html>
