<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/14/24341079_cse422_14_labassignment1_-_MESHKATUL_AREFIN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/14/24341079_cse422_14_labassignment1_-_MESHKATUL_AREFIN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""24341079_CSE422_14_LabAssignment1

Automatically generated by Colab.

<a name="1"></a><font color="#00FF00"><a href="match172-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_13.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/15mGsWAacVxqY9P2yUC6uJdqgY9pbjNPH
"""

# Downloading heapq.
import heapq

# Gathering heuristic values of all the nodes / manipulating the input text file
input_file = open("/content/Input file.txt", "r")

def heuristicValue(input_file):
    city_heuristics = {}
    neighbor_heuristics  = {}
    temp_heuristics_holder = {}

    for each_line in input_file:
        list_of_cities = each_line.strip().split()
</font>        len_of_city_list = len(list_of_cities)

        city_heuristics[list_of_cities[0]] = int(list_of_cities[1]) #own hurestic value

        for city_index in range(2, len_of_city_list, 2): #hurestic distance of connected cities
          temp_heuristics_holder[list_of_cities[city_index]] = int(list_of_cities[city_index+1])

        neighbor_heuristics[list_of_cities[0]] = temp_heuristics_holder
        temp_heuristics_holder = {}

    return (city_heuristics, neighbor_heuristics)

<a name="2"></a><font color="#0000FF"><a href="match172-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

city_heuristics, neighbor_heuristics= heuristicValue(input_file)
# print(city_heuristics)
# print(neighbor_heuristics)

# A star algorithm

def a_star(start, goal, neighbor_heuristics, city_heuristics):
    visited_city_track = []
    heapq.heappush(visited_city_track, (0, start))
    actual_path = {}
    cost = {}
    actual_path[start] = None # Changed 'star' to 'start'
</font>    cost[start] = 0


    while visited_city_track:
        current_city = heapq.heappop(visited_city_track)[1]

        if current_city == goal:
            break

        for neighbor_city in neighbor_heuristics[current_city]:
            new_cost = cost[current_city] + neighbor_heuristics[current_city][neighbor_city]
            if neighbor_city not in cost or new_cost &lt; cost[neighbor_city]:
                cost[neighbor_city] = new_cost
                priority = new_cost + city_heuristics[neighbor_city]
<a name="0"></a><font color="#FF0000"><a href="match172-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

                heapq.heappush(visited_city_track, (priority, neighbor_city))
                actual_path[neighbor_city] = current_city

    return actual_path, cost

# function to generate the required output and backtracking

def outputBuilder(path, cost, start, goal):
    current_city = goal
    actual_path = []

    while current_city is not start:
      actual_path.append(current_city)
      new_city = path[current_city]
      current_city = new_city
    actual_path.append(start)

    if len(actual_path) != 0:
</font>      actual_path.reverse()
      print(*actual_path, sep = " --&gt; ")
    else:
      print("NO PATH FOUND!")
    print(f'Total distance: {cost[goal]} km')

#input and call the functions

start = input("Enter the start node: ")
goal = input("Enter the goal node: ")

if start and goal not in city_heuristics:
    print("Start or goal does not exist.")
else:
    path, cost = a_star(start, goal, neighbor_heuristics, city_heuristics)
    outputBuilder(path, cost, start, goal)</pre>
</body>
</html>
