<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/6/21101096_a_b_m_danial_cse422_06_assignment01_fall2024_-_A.B.M_DANIAL.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/17/19101043_nowshin_cse422_17_assignment01_fall2024_-_Nowshin_Yeasmin_Fariha.py<p></p><pre>
# -*- coding: utf-8 -*-
"""19101043_Nowshin_CSE422_17_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sZiyqIKr92d-xslOSwN7JeS2f3t2KACg
"""

from google.colab import files

# Function to read the input graph from a file
<a name="2"></a><font color="#0000FF"><a href="match23-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

def inp_graph(inp_file):
    # Initialize an empty dictionary to store the graph
    graph = {}

    with open(inp_file, "r") as file:
        # Iterate through each line in the file
        for line in file:
            # Split the line to extract city, heuristic, and neighbor information
            s_line = line.split()
            city = s_line[0]
</font>            heuristic = int(s_line[1])
            neighbor = {}

            # Iterate through each neighbor and its distance and add to the neighbor dictionary
            for i in range(2, len(s_line), 2):
                edge = s_line[i]
<a name="0"></a><font color="#FF0000"><a href="match23-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_54.gif"/></a>

                distance = int(s_line[i + 1])
                neighbor[edge] = distance

            # Create a dictionary for the city containing its heuristic and neighbor information
            graph[city] = {"h": heuristic, "e": neighbor}

    # Return the final graph dictionary
    return graph

# A* algorithm implementation
def a_star(start, goal, graph):
    open_Set = {start}
    closed_Set = set()
    path_cost = {start: 0}
    final_Cost = {start: graph[start]["h"]}
    track_p = {}

    while open_Set:
        cost_node = min(open_Set, key=lambda node: final_Cost[node])

        if cost_node == goal:
            path_c = [cost_node]
            while cost_node in track_p:
                cost_node = track_p[cost_node]
                path_c.append(cost_node)
            path_c.reverse()
            return (final_Cost[goal], path_c)

        open_Set.remove(cost_node)
        closed_Set.add(cost_node)

        for edge, d in graph[cost_node]["e"].items():
            if edge in closed_Set:
                continue

            temp_cost = path_cost[cost_node] + d

            if edge not in open_Set:
                open_Set.add(edge)
            elif temp_cost &gt;= path_cost[edge]:
                continue

            track_p[edge] = cost_node
            path_cost[edge] = temp_cost
            final_Cost[edge] = path_cost[edge] + graph[edge]["h"]

    return None

# Function to print the shortest path and its distance
def main():
</font>    # Upload the file and get the file name
    uploaded = files.upload()
    inp_file = list(uploaded.keys())[0]  # Get the uploaded file name

    # Read the graph from the input file
    graph = inp_graph(inp_file)

    # Ask the user to enter the start and destination cities
<a name="1"></a><font color="#00FF00"><a href="match23-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

    start = input("Start node: ")
    goal = input("Destination: ")

    # Run the A* algorithm to find the shortest path
    result = a_star(start, goal, graph)

    # Check if a path is found or not and print the result accordingly
    if result is None:
        print("NO PATH FOUND")
    else:
        distance, path = result
        print("Path:", " -&gt; ".join(path))
        print("Total Distance:", distance, "Km")


# Entry point of the script
if __name__ == "__main__":
</font>    main()</pre>
</body>
</html>
