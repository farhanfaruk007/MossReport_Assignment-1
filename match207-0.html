<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/6/21101165_miftahuljannatorpi_cse422_06_assignment01_fall2024_-_MIFTAHUL_JANNAT_ORPI.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/6/21101165_miftahuljannatorpi_cse422_06_assignment01_fall2024_-_MIFTAHUL_JANNAT_ORPI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21101165_MiftahulJannatOrpi_CSE422_06_Assignment01_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qXL4Dx-0bovqvQXewDsyzeQ0UwOkLyy9
"""

input_file = open("/content/Input_file.txt")
graph = {}
heuristic = {}

# Parse each line in the input file graph and heruistic table create korar jonno
for line in input_file:
    components = line.split()
    main_node = components[0]
    main_heuristic = int(components[1])
    neighbors = components[2:]

    heuristic[main_node] = main_heuristic

    adj_nodes = []
    for j in range(0, len(neighbors), 2):
        neighbor_node, distance = neighbors[j], int(neighbors[j + 1])
        adj_nodes.append((neighbor_node, distance))

    graph[main_node] = adj_nodes  # adjacency list e add hocche

# Basically heapq import for the priority queue
import heapq


def a_star_search(start, goal):
    priority_queue = []
    heapq.heappush(priority_queue, (0 + heuristic[start], start))

<a name="1"></a><font color="#00FF00"><a href="match207-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_9.gif"/></a>

    cost_tracker = {start: 0}
    previous_node = {}  #path trace is stored here

    while priority_queue:
        current_cost, current_node = heapq.heappop(priority_queue)  # getting node with lowest cost


        if current_node == goal:
            path_trace = []
            while current_node in previous_node:
</font>                path_trace.append(current_node)
                current_node = previous_node[current_node]
            path_trace.append(start)
<a name="0"></a><font color="#FF0000"><a href="match207-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_29.gif"/></a>

            path_trace.reverse()
            return path_trace, cost_tracker[goal]

        # path cost calculate and compare hocche
        for neighbor, distance in graph[current_node]:
            new_cost = cost_tracker[current_node] + distance
            if neighbor not in cost_tracker or new_cost &lt; cost_tracker[neighbor]:
                previous_node[neighbor] = current_node
                cost_tracker[neighbor] = new_cost
                estimated_cost = new_cost + heuristic[neighbor]
                heapq.heappush(priority_queue, (estimated_cost, neighbor))

    return None

# User input
start_city = input("Start City:")
goal_city = input("Destination City:")
path, total_cost = a_star_search(start_city, goal_city)

print("Path:", path)
print("Total distance:", total_cost)</font></pre>
</body>
</html>
