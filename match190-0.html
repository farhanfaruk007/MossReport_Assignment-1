<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101002_Radiah_Hassan_CSE422_07_Assignment01_Fall2024_-_RADIAH_HASSAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101002_Radiah_Hassan_CSE422_07_Assignment01_Fall2024_-_RADIAH_HASSAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101002_Radiah Hassan_CSE422_07_Assignment01_Fall2024

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y_lfXOA10P5M3XnHsxspT6mu_Qu-lumJ
"""

input_file = open('input.txt', 'r')

#Heuristic function
def heuristic(input_file):
    h_list = {} #store heuristic values
    for line in input_file:
        line = line.strip().split()
        h_list[line[0]] = int(line[1])
    return h_list
h_val = heuristic(input_file)

input_file.close()


input_file = open('input.txt', 'r') #opens file to read adjacency list
adj_graph = {} #store adjacency graph

for line in input_file:
    line = line.strip().split()
    node = line[0]
    adj_graph[node] = {} #store neighbors
    # Parse child nodes and their respective distances
    for index in range(2, len(line), 2):
        adj_graph[node][line[index]] = int(line[index + 1])

input_file.close()


#PriorityQueue class
import heapq as hq

class PriorityQueue:
    def __init__(self):
        self.elements = []

    def isEmpty(self):
        return len(self.elements) == 0

    def push(self, city, cost):
<a name="0"></a><font color="#FF0000"><a href="match190-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_22.gif"/></a>

        hq.heappush(self.elements, (cost, city))

    def pop(self):
        return hq.heappop(self.elements)[1]


#A* search algorithm
def astar(start, goal, adj_graph, h_val):
    dist = {} #track min dist from start to each node
    path = {} #track parent of each node
    q = PriorityQueue()
    q.push(start, 0)
    dist[start] = 0
    path[start] = None
    expanded_list = [] #expanded nodes

    while not q.isEmpty():
        current = q.pop()
        expanded_list.append(current)
        if current == goal:
            break

        for neighbor, cost in adj_graph[current].items():
            g_cost = dist[current] + cost
</font><a name="1"></a><font color="#00FF00"><a href="match190-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

            if neighbor not in dist or g_cost &lt; dist[neighbor]:
                dist[neighbor] = g_cost
                f_cost = g_cost + h_val[neighbor]
                q.push(neighbor, f_cost)
                path[neighbor] = current
</font>
    return path, dist, expanded_list

#Function to reconstruct and print the path
def output_print(path, dist, start, goal):
    if goal not in path:
        print('NO PATH FOUND!')
        return

    route = [] #store nodes in path
    current = goal
    while current:
        route.append(current)
        current = path[current]
    route.reverse()

    print('Path:', ' -&gt; '.join(route))
    print('Total Distance:' , dist[goal], 'km')

# Main program execution
start = input('Start node: ')
goal = input('Destination: ')

if start not in h_val or goal not in h_val:
    print('NO PATH FOUND!')
else:
    path, dist, expanded_list = astar(start, goal, adj_graph, h_val)
    output_print(path, dist, start, goal)</pre>
</body>
</html>
