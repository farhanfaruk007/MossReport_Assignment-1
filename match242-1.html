<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/1/22101614_shaikh_mohammad_ali_shams_cse422_01_assignment01_fall2024_-_SHAIKH_MOHAMMAD_ALI_SHAMS.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/5/24141190_Lab1_Sec5_-_MD._REZWAN_AZIZ_PRINCE.py<p></p><pre>

<a name="1"></a><font color="#00FF00"><a href="match242-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

import heapq

def read_graph_data():
    city_connections = {}
    city_heuristics = {}
    with open("E:\\Prince_422\\pythonProject1\\Input file.txt", 'r') as file:
        for line in file:
            parts = line.strip().split()
            city = parts[0]
</font>            heuristic_value = int(parts[1])
            city_heuristics[city] = heuristic_value
            neighbors = []
            for i in range(2, len(parts), 2):
                neighbor_city = parts[i]
                travel_distance = int(parts[i + 1])
<a name="2"></a><font color="#0000FF"><a href="match242-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_11.gif"/></a>

                neighbors.append((neighbor_city, travel_distance))
            city_connections[city] = neighbors
    return city_connections, city_heuristics

def find_optimal_route(city_connections, city_heuristics, origin, destination):
    open_cities = []
    heapq.heappush(open_cities, (0, origin))
    route_history = {}
</font>    actual_cost = {origin: 0}
    estimated_cost = {origin: city_heuristics[origin]}

    while open_cities:
        _, current_city = heapq.heappop(open_cities)

        if current_city == destination:
            optimal_path = []
            while current_city in route_history:
                optimal_path.append(current_city)
<a name="0"></a><font color="#FF0000"><a href="match242-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

                current_city = route_history[current_city]
            optimal_path.append(origin)
            return optimal_path[::-1], actual_cost[destination]

        for adjacent_city, travel_distance in city_connections[current_city]:
            projected_cost = actual_cost[current_city] + travel_distance
            if adjacent_city not in actual_cost or projected_cost &lt; actual_cost[adjacent_city]:
</font>                route_history[adjacent_city] = current_city
                actual_cost[adjacent_city] = projected_cost
                estimated_cost[adjacent_city] = projected_cost + city_heuristics[adjacent_city]
                heapq.heappush(open_cities, (estimated_cost[adjacent_city], adjacent_city))

    return None, None

def main():
    origin = input("Enter the start node: ")
    destination = input("Enter the goal node: ")

    city_connections, city_heuristics = read_graph_data()
    optimal_path, total_cost = find_optimal_route(city_connections, city_heuristics, origin, destination)

    if optimal_path:
        print("Path:", " -&gt; ".join(optimal_path))
        print("Total distance:", total_cost, "km")
    else:
        print("NO PATH FOUND")

if __name__ == "__main__":
    main()
</pre>
</body>
</html>
