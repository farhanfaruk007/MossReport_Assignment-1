<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/21201770_Amit_kumer_Halder_cse422_07_assignment01_fall2024_py_-_AMIT_KUMER_HALDER.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/11/21301180_fahmida_akter_rimo_cse422_11_lab_assignment1_fall2024_-_FAHMIDA_AKTER_RIMO.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21301180_Fahmida Akter Rimo_CSE422_11_Lab_Assignment1_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AJrRc3Uf5RIcHmbWTdIELOjEV0DkrEf8
"""

import heapq

<a name="2"></a><font color="#0000FF"><a href="match86-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_14.gif"/></a>

input_file=open("/content/inputfile.text","r")
output_file=open("/content/outputfile.text","w")
input_lines=input_file.readlines()

locations=[]
estimated_cost_list=[]
edges=[]

for line in input_lines:
  data=line.strip().split()
  locations.append(data[0])
  estimated_cost_list.append(int(data[1]))

  edge_info=[]
</font>  for i in range (2,len(data),2):
    neighbour=data[i]
    distance=int(data[i+1])
    edge_info.extend([neighbour,distance])
  edges.append(edge_info)

#user input for start and goal
start_location=input("Start location: ")
goal_location=input("Destination location: ")


#constructing A* structure
priority_queue=[]
start_index=locations.index(start_location)
start_estimated_cost=estimated_cost_list[start_index]

heapq.heappush(priority_queue, (start_estimated_cost, start_location))

previous_location={}

cost_from_start={location: float('inf') for location in locations}
cost_from_start[start_location]=0

estimated_cost={location: float('inf') for location in locations}
estimated_cost[start_location]= start_estimated_cost


#A* algorithm
while priority_queue:
  f_score, current_location= heapq.heappop(priority_queue)

<a name="0"></a><font color="#FF0000"><a href="match86-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_16.gif"/></a>

  if current_location==goal_location:
    path=[]
    total_distance= cost_from_start[goal_location]
    while current_location in previous_location:
      path.insert(0, current_location)
      current_location= previous_location[current_location]
    path.insert(0,start_location)



    #printcase
    path_str= " -&gt; ".join(path)
    print(path_str)
    print("Total distance: ", total_distance,"km")
    output_file.write(path_str + "\n")
    output_file.write("Total distance: "+ str(total_distance)+"km")
    break

  location_index= locations.index(current_location)
</font><a name="1"></a><font color="#00FF00"><a href="match86-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_14.gif"/></a>

  neighbours= edges[location_index]

  for i in range (0, len(neighbours), 2):
    neighbour_location = neighbours[i]
    travel_distance= neighbours[i+1]

    current_cost_to_reach_neighbour = cost_from_start[current_location] + travel_distance
    if current_cost_to_reach_neighbour &lt; cost_from_start[neighbour_location]:
      previous_location[neighbour_location] = current_location
      cost_from_start[neighbour_location] = current_cost_to_reach_neighbour
</font>      total_estimated_cost = current_cost_to_reach_neighbour + estimated_cost_list[locations.index(neighbour_location)]
      heapq.heappush(priority_queue, (total_estimated_cost, neighbour_location))
else:
  print("NO PATH FOUND")
  output_file.write("NO PATH FOUND")

input_file.close()
output_file.close()</pre>
</body>
</html>
