<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/2/21201199_lab1_sec2_-_MD._ZAHIDUL_HASAN_ZIAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/2/21201199_lab1_sec2_-_MD._ZAHIDUL_HASAN_ZIAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201199_Lab1_Sec2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mdU04J3bz-MVBzKcvRTtCq8dZwNXkQLU
"""

file_path = "/content/inputfile.txt"

city_data = {}
heuristic_values = {}

with open(file_path, 'r') as file:
    file_contents = file.readlines()

<a name="0"></a><font color="#FF0000"><a href="match185-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_18.gif"/></a>

    for line in file_contents:
        city_info = line.split()
        city_name = city_info[0]
        num_neighbors = len(city_info)

        heuristic_values[city_name] = int(city_info[1])

        for i in range(2, num_neighbors, 2):
            if city_name not in city_data:
                city_data[city_name] = {}
            city_data[city_name][city_info[i]] = int(city_info[i + 1])
</font>

import heapq

def reconstruct_path(parents, destination):
    path = []
    current_node = destination
    while current_node in parents:
        path.insert(0, current_node)
        current_node = parents[current_node]
    path.insert(0, current_node)
    return path

def A_star_search(city_data, heuristic_values, start_city, end_city):
    open_list = []
    closed_list = set()
<a name="2"></a><font color="#0000FF"><a href="match185-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    g_scores = {start_city: 0}
    parents = {}

    f_score = heuristic_values[start_city] + g_scores[start_city]
    heapq.heappush(open_list, (f_score, start_city))

    while open_list:
        current_f_score, current_city = heapq.heappop(open_list)
</font>
        if current_city == end_city:
            path = reconstruct_path(parents, end_city)
            total_distance = g_scores[end_city]
            return path, total_distance

        closed_list.add(current_city)

        for neighbor, distance in city_data[current_city].items():
            if neighbor in closed_list:
                continue

            tentative_g_score = g_scores[current_city] + distance

            if neighbor in g_scores and tentative_g_score &gt;= g_scores[neighbor]:
                continue

            g_scores[neighbor] = tentative_g_score
            f_score = tentative_g_score + heuristic_values[neighbor]
            heapq.heappush(open_list, (f_score, neighbor))
            parents[neighbor] = current_city

<a name="1"></a><font color="#00FF00"><a href="match185-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

    return None, -1  # No path found


# Part 3

start_city = input("Please enter the starting city: ")
end_city = input("Please enter the destination city: ")

# Calling A* search function
path, total_distance = A_star_search(city_data, heuristic_values, start_city, end_city)

# Results
if path is None:
    print("NO PATH FOUND")
else:
    print("Path:", " -&gt; ".join(path))
</font>    print("Total distance:", total_distance, "km")</pre>
</body>
</html>
