<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101135_fahim_cse422_07_assignment01_fall2024_-_ARFAN_AHMED_FAHIM.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101281_sadia_cse422_07_assignment1_fall2024_-_MOST._SADIA_SULTANA_TAMIM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101281_Sadia_CSE422_07_Assignment1_Fall2024.ipynb

Automatically generated by Colab.

<a name="0"></a><font color="#FF0000"><a href="match5-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_31.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/1uiE7vpxyyBW9hd0YbWte8KRyI0oczkOX
"""

import heapq as hq
class PriorityQueue:
  def __init__(self):
    self.cities= []
  def push(self, city, cost):
    hq.heappush(self.cities,(cost,city))
  def pop(self):
    return hq.heappop(self.cities)[1]
  def isEmpty(self):
    if (self.cities==[]):
      return True
    else:
      return False
  def check(self):
    print(self.cities)


def make_dictionary():
  r_map = {}
  h_map = {}
  with open("SADIA.txt", "r") as files:
    for i in files:
      line= i.strip()
      if not line:
        continue
      parts= line.split()
      if len(parts) &lt; 2:
        continue
      city = parts[0]
      heuristic_distance = int(parts[1])
</font><a name="2"></a><font color="#0000FF"><a href="match5-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_19.gif"/></a>


      if city not in r_map:
        r_map[city] = {}

      if city not in h_map:
        h_map[city] = heuristic_distance

      for j in range(1, len(parts), 2):
        if j+1&gt;= len(parts):
          continue
        else:
          distance = int(parts[j+2])
          close_city = parts[j+1]

          r_map[city][close_city] = distance

  return r_map, h_map

def astar(start,end):
  main_path = {}
  distance = {}
  q= PriorityQueue()
</font>  r_city, heuristic_value = make_dictionary()


  q.push(start,0)
  distance [start] = 0
  main_path [start] = None
  visitedNode = []
<a name="1"></a><font color="#00FF00"><a href="match5-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_21.gif"/></a>

  while not q.isEmpty():
    present_node = q. pop()
    visitedNode. append(present_node)
    if (present_node == end ):
      break

    for visited_city in r_city[present_node]:

      g_cost =  distance[present_node] + r_city[present_node][visited_city]
      if (visited_city not in distance or g_cost &lt; distance[visited_city]):
        distance[visited_city] = g_cost
        f_cost = g_cost + int(heuristic_value[visited_city])
        q.push (visited_city, f_cost)
        main_path [visited_city] = present_node

  output(start,end,main_path, distance, visitedNode)

def output(start, end ,main_path, distance, visitedNode):
  original_path = []
</font><a name="3"></a><font color="#00FFFF"><a href="match5-0.html#3" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

  while end is not None:
    original_path.append(end)
    end = main_path.get(end)
  original_path.reverse()

  if len(original_path) == 1 and original_path[0] != start:
    print(f"No path found from {start} to {end}")
</font>  else:
    print(f"Path from {start} to {original_path[-1]}: {' -&gt; '.join(original_path)}")
  print(f"Total Number of Cities in final path are: {len(original_path)}")
  print()
  print(f"Expanded List: {visitedNode}")
  print(f"Total Number of Cities that are expanded: {len(visitedNode)}")
  print()
  print(f"Total Cost:{distance[original_path[-1]]}")

Starting_point = "Arad"
Ending_point = "Bucharest"
astar("Arad","Bucharest")

</pre>
</body>
</html>
