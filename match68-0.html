<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/15/22301678_a_z_m_bodruddoza_bijoy_cse422_15_lab_assignment01_fall2024_-_A_Z_M_BODRUDDOZA_BIJOY.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/15/22301678_a_z_m_bodruddoza_bijoy_cse422_15_lab_assignment01_fall2024_-_A_Z_M_BODRUDDOZA_BIJOY.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22301678_a z m bodruddoza bijoy_CSE422_15_Lab_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qDa5r9zkEi_YSlD7f1GtLGGhS1a3Hz6U
"""

import heapq
<a name="0"></a><font color="#FF0000"><a href="match68-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_14.gif"/></a>

def graph(input):
    adj_graph = {}
    tmp_adj = {}
    for line in input:
        values = line.strip().split()
        for i in range(2, len(values), 2):
            tmp_adj[values[i]] = int(values[i + 1])
        adj_graph[values[0]] = tmp_adj
        tmp_adj = {}
    return adj_graph
def heuristics(input):
</font>    h = {}
<a name="4"></a><font color="#FF00FF"><a href="match68-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_6.gif"/></a>

    for line in input:
        values = line.strip().split()
        h[values[0]] = int(values[1])
    return h
def a_star(start, end, adj_graph, heuristics):
</font>    queue = []
    heapq.heappush(queue, (0, start))
<a name="1"></a><font color="#00FF00"><a href="match68-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

    backpath = {start: None}
    cost = {start: 0}
    while queue:
        c_node = heapq.heappop(queue)[1]
        if c_node == end:
            break
        for neighbor in adj_graph[c_node]:
</font>            new_cost = cost[c_node] + adj_graph[c_node][neighbor]
            if neighbor not in cost or new_cost &lt; cost[neighbor]:
                cost[neighbor] = new_cost
<a name="2"></a><font color="#0000FF"><a href="match68-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

                estimated_cost = new_cost + heuristics[neighbor]
                heapq.heappush(queue, (estimated_cost, neighbor))
                backpath[neighbor] = c_node
    return backpath, cost
def path(backpath, cost):
    route = []
    route.append(end)
    node = end

    while node != start:
</font>        node = backpath[node]
        route.append(node)

    route.reverse()

    if route != None:
<a name="3"></a><font color="#00FFFF"><a href="match68-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_7.gif"/></a>

        print("Path: ", end='')
        for place in route:
            print(place, end=" --&gt; " if place != route[-1] else "\n")
        print("Total distance:", cost[end], "km")
</font>    else:
        print("NO PATH FOUND!")

sample_input = open("Input.txt", "r")
adj_graph = graph(sample_input)
print(adj_graph)
sample_input.close()

sample_input = open("Input.txt", "r")
heuristics = heuristics(sample_input)
print(heuristics)
sample_input.close()

start = input("Enter the start node: ")
end = input("Enter the end node: ")

if start in heuristics and end in heuristics:
    backpath,cost = a_star(start, end, adj_graph, heuristics)
    path(backpath, cost)

else:
    print("Start or end does not exist. Please check the node names.")</pre>
</body>
</html>
