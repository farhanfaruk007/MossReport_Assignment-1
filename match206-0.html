<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101081_humayra_anjum_nisha_cse422_07_assignment01_fall2024_-_HUMAYRA_ANJUM_NISHA.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101081_humayra_anjum_nisha_cse422_07_assignment01_fall2024_-_HUMAYRA_ANJUM_NISHA.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101081_Humayra Anjum Nisha_CSE422_07_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

<a name="0"></a><font color="#FF0000"><a href="match206-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_22.gif"/></a>

Original file is located at
    https://colab.research.google.com/drive/1my7VGQwv9QMKMC1FLHklpx04gZ8NnWUd
"""

input= open("/content/drive/MyDrive/CSE422/CSE422_LAB/input.txt", "r")
def hueristic_dict(input):
  val= {}
  for cities in input:
    new_list= cities. strip(). split()
    val[new_list[0]]= int(new_list[1])
  return val
val= hueristic_dict(input)


#heuristic = {'Arad': 366, 'Craiova': 160, 'Eforie': 161, 'Fagaras': 176, 'Giurgiu': 77, 'Mehadia': 241, 'Neamt': 234, 'Sibiu': 253, 'Oradea': 380, 'Pitesti': 100, 'RimnicuVilcea': 193, 'Dobreta': 242, 'Hirsova': 151, 'lasi': 226, 'Lugoj': 244, 'Timisoara': 329, 'Urziceni': 80, 'Vaslui': 199, 'Zerind': 374, 'Bucharest': 0}

input= open("/content/drive/MyDrive/CSE422/CSE422_LAB/input.txt", "r")
val_adj= {}
other_adj= {}
for cities in input:
  new_list= cities. strip(). split()
  val_adj[new_list[0]]= []
</font>  for i in range(2, len(new_list), 2):
    val_adj[new_list[0]].append((new_list[i], int(new_list[i+1])))


<a name="1"></a><font color="#00FF00"><a href="match206-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

import heapq
def a_star(start, goal, val_adj, heuristic):
  city_all= []
  heapq.heappush(city_all, (0, start))
  fst_ct= {}
  dist_road ={}
  fst_ct[start]= None
</font>  dist_road[start]= 0
  while city_all:
    build= heapq.heappop(city_all)[1]
    if build== goal:
      break
    for city in val_adj[build]:
      if city[0] not in fst_ct or dist_road[build]+ city[1]&lt; dist_road[city[0]]:
        fst_ct[city[0]]= build
        dist_road[city[0]]= dist
        heapq.heappush(city_all, (dist_road[city[0]]+ heuristic[city[0]], city[0]))
    return fst_ct, dist_road

def output (fst_ct, dist_road):
  val_dist= []
  val_dist. append(goal)
  ct= goal
  while ct != start:
    ct= fst_ct [ct]
    val_dist .append (ct)
  val_dist.reverse ()
  if len(val_dist) ==0:
    print("NO PATH FOUND!")
  else:
    str_path= " --&gt; ".join(val_dist)
        print(f"Path: {str_path}")

        print(f"Total distance: {dist_road[goal]} km")





def main():
    start_city = input("Enter the starting city: ")
    goal_city = input("Enter the goal city: ")

    if start_city and goal_city not in val:
        print("City not found in the graph.")
        return

    else:
      fst_ct, dist_road = a_star(start_city, goal_city, val_adj, val)
      output(fst_ct, dist_road)

if __name__ == "__main__":
    main()</pre>
</body>
</html>
