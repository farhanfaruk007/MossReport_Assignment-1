<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101362_plabon_mondal_cse422_07_assignment01_fall2024_-_PLABON_MONDAL.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/9/22101337__tanvir_22101337_-_Mr._TANVIR.py<p></p><pre>
# -*- coding: utf-8 -*-
"""Tanvir_22101337

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ea1XM4KiG7TiBpu_oqs4KB4bFUty9l0W
"""

f = open("/content/Assignment 1.txt","r")
path_info = f.readlines()
# print(path_info)
heuristic_val = {}
cost = {}
for i in range(len(path_info)):
  # print(path_info[i])
  individual_info = path_info[i].split( )
  # print(individual_info)
  # print(individual_info[2::])
  heuristic_val[individual_info[0]]=int(individual_info[1])
  cost[individual_info[0]]=[]
  # print("info",individual_info)
  for j in range(2,len(individual_info)):
<a name="1"></a><font color="#00FF00"><a href="match46-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_6.gif"/></a>

    if j%2==0:
      cost[individual_info[0]].append([individual_info[j],int(individual_info[j+1])])
# print(cost)
# print(heuristic_val)
# print("############################################")
boolean = True
</font>optimal_path_idx = []
optimal_path_parent = []
start_node = input("enter the node: ")
destination = input("enter where to reach: ")
queue = []
queue.append([heuristic_val[start_node],start_node])
# print(queue)
poped_city = None
while poped_city!= destination:
  if len(queue)==0:
    boolean = False
    break
  else:
<a name="0"></a><font color="#FF0000"><a href="match46-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_50.gif"/></a>

    poped_list = queue.pop(0)
    poped_city_distance = poped_list[0]
    poped_city = poped_list[1]
    # print("poped_city",poped_city)
    # print("poped_city_distance",poped_city_distance)
    child_node = cost[poped_city]
    # print("neighbour",child_node)
    for i in child_node:
      city = i[0]
      distance = i[1]
      cost_so_far = poped_city_distance - heuristic_val[poped_city]
      # print("cost",cost_so_far)
      merged_cost = cost_so_far + distance + heuristic_val[city]

      if city not in optimal_path_idx:
        queue.append([merged_cost,city])
        optimal_path_idx.append(city)
        optimal_path_parent.append(poped_city)
        # print(optimal_path)
        # print(optimal_path_parent)
      else:
        for i in range(len(queue)):
          if city== queue[i][1]:
            dis = queue[i][0]
            index = i
            if dis&gt;merged_cost:
              queue.pop(index)
              queue.append([merged_cost,city])
              removed_idx = optimal_path_idx.index(city)
              optimal_path_idx.pop(removed_idx)
              optimal_path_parent.pop(removed_idx)
              optimal_path_idx.append(city)
              optimal_path_parent.append(poped_city)
    queue.sort()
    # print("queue",queue)
# print(optimal_path_parent)
if boolean == False:
  print("No path found")
else:
  path =[]
  path.append(destination)
  parent = None
  while parent!=start_node:
    idx = optimal_path_idx.index(destination)
    parent = optimal_path_parent[idx]
    path.append(parent)
    destination = parent

  path.reverse()
</font>  # print(path)
  print("Path:", " -&gt; ".join(path))
  print(poped_city_distance ,"KM")



</pre>
</body>
</html>
