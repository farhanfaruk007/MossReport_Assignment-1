<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/11/21301628_Samin_Haque_Sec11_Lab1_-_SAMIN_HAQUE.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/11/21301628_Samin_Haque_Sec11_Lab1_-_SAMIN_HAQUE.py<p></p><pre>
from heapq import heappop, heappush

input_file = r"C:\\Users\\SkyN3\\Downloads\\AI_422_Labs\\input file.txt"
graph = {}
heuristics = {}
possible_last_hops = {} # This dictionary is initialize to store all the parent nodes of the goal node.
f_of_n = {}
g_of_n = {}
parents = []
total_distance = 0

<a name="2"></a><font color="#0000FF"><a href="match173-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

with open(input_file, 'r') as map_of_Romania:
    for neighbouring_paths in map_of_Romania:

        split_line_to_string = neighbouring_paths.split()
        temp = []
        
        for paths in range(2, len(split_line_to_string)):
</font><a name="1"></a><font color="#00FF00"><a href="match173-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

            if paths % 2 == 0 and paths + 1 &lt; len(split_line_to_string):
                temp.append((split_line_to_string[paths], int(split_line_to_string[paths + 1])))

        graph[split_line_to_string[0]] = temp

        heuristics[split_line_to_string[0]] = int(split_line_to_string[1])
</font>
# print(graph)
# print(heuristics)


def a_star_search(graph, start_node, goal_node, heuristics):
    
    open_list, closed_list = [(heuristics[start_node], start_node)], set()

    while open_list:
        actual_cost, node = heappop(open_list)
        parents.append(node)

        if node == goal_node:
            return {actual_cost: parents}
        
<a name="0"></a><font color="#FF0000"><a href="match173-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_17.gif"/></a>

        if node in closed_list:
            continue

        closed_list.add(node)
        actual_cost -= heuristics[node]

        for neighbour, edge_cost in graph[node]:
            if neighbour in closed_list:
                continue
            if neighbour == goal_node:
                possible_last_hops[node] = (neighbour, actual_cost + edge_cost)

            evaluation_func = actual_cost + edge_cost + heuristics[neighbour]
            heappush(open_list, (evaluation_func, neighbour))

    return -1
</font>

start, destination = input("Start node: "), input('Destination: ')
total_path_cost = a_star_search(graph, start, destination, heuristics)
total_distance = list(total_path_cost.keys())[0]

if total_path_cost != -1:

    if heuristics[destination] != 0:
        total_distance -= heuristics[destination]
    
    path = list(total_path_cost.values())[0]
    alternate_paths_to_goal = []
    min_path_cost = min(possible_last_hops.values())
    # print(min_path_cost)

    for k, v in possible_last_hops.items():
        if v != min_path_cost:
            alternate_paths_to_goal.append(k)
    # print(alternate_paths_to_goal)

    # HERE ALL THE OTHER ALTERNATIVE PATHS TOWARDS THE GOAL NODE IS REMOVED EXCEPT FOR THE PATH WITH THE LOWEST PATHCOST g(n)
    for i in alternate_paths_to_goal:
        path.remove(i)

    print(f'Path: ', end='')
    for p in range(len(path) - 1):
        print(path[p], end=' -&gt; ')
    print(path[-1])
    print(f"Total Distance: {total_distance} km")

else:
    print('NO PATH FOUND')

# print(possible_last_hops)</pre>
</body>
</html>
