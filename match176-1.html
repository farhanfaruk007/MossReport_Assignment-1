<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/6/20201217_Tanzina_Binte_Azad_CSE422_06_Assignment01_Fall2024.py_-_TANZINA_BINTE_AZAD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/22101135_fahim_cse422_07_assignment01_fall2024_-_ARFAN_AHMED_FAHIM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101135_Fahim_CSE422_07_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bcwyr1IBnGi9onTOwOdd7QMXRqq5wsfa
"""

import heapq as hq
<a name="0"></a><font color="#FF0000"><a href="match176-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_13.gif"/></a>

class PriorityQueue:
  def __init__(self):
    self.cities= []
  def push(self, city, cost):
    hq.heappush(self.cities,(cost,city))
  def pop(self):
    return hq.heappop(self.cities)[1]
  def isEmpty(self):
    if (self.cities==[]):
      return True
    else:
      return False
  def check(self):
    print(self.cities)
</font>

def makeMap():
  romania_map = {}
  heuristic_map = {}
  with open("Romania.txt", "r") as files:
    for i in files:
      line= i.strip()
      if not line:
        continue
      parts= line.split()
      if len(parts) &lt; 2:
        continue
      city = parts[0]
      h_distance = parts[1]

      if city not in romania_map:
        romania_map[city] = {}

      if city not in heuristic_map:
        heuristic_map[city] = h_distance

      for j in range(1, len(parts), 2):
        if j+1&gt;= len(parts):
          continue
        else:
          distance = int(parts[j+2])
          neighbor = parts[j+1]

          romania_map[city][neighbor] = distance

  return romania_map, heuristic_map

def astar(start,end):
  path = {}
  distance = {}
  q= PriorityQueue()
  romania_city = makeMap()[0]

  heuristic_val = makeMap()[1]
<a name="1"></a><font color="#00FF00"><a href="match176-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

  q.push(start,0)
  distance [start] = 0
  path [start] = None
  expandedList = []
  while (q.isEmpty() == False):
    current = q. pop()
    expandedList. append(current)
    if (current == end ):
      break

    for new_city in romania_city[current]:

      g_cost =  distance[current] + romania_city[current][new_city]
</font>      if (new_city not in distance or g_cost &lt; distance[new_city]):
        distance[new_city] = g_cost
        f_cost = g_cost + int(heuristic_val[new_city])
        q.push (new_city, f_cost)
        path [new_city] = current

  output(start,end,path, distance, expandedList)

def output(start,end,path, distance, expandedList):
  mainpath = []
  counter = 0
  while end is not None:
    mainpath.append(end)
    end = path.get(end)
  mainpath.reverse()

  if len(mainpath) == 1 and mainpath[0] != start:
    print(f"No path found from {start} to {end}")
  else:
    counter +=1
    print(f"Path from {start} to {mainpath[-1]}: {' -&gt; '.join(mainpath)}")
  print(f"Total Number of Cities in final path are: {len(mainpath)}")
  print()
  print(f"Expanded List: {expandedList}")
  print(f"Total Number of Cities that are expanded: {len(expandedList)}")
  print()
  print(f"Total Cost:{distance[mainpath[-1]]}")

Starting_point = "Arad"
Ending_point = "Bucharest"
astar("Arad","Bucharest")

</pre>
</body>
</html>
