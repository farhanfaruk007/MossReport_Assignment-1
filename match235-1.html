<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/5/22121116_lab1_sec5_-_SK._ZAYED_MAHMOOD.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/8/21201102_nahiyantabassum_08_-_NAHIYAN_TABASSUM.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201102_NahiyanTabassum_08.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yQPpzHfEurEIDocjdXgHIrMcaE1zDQDC
"""

import heapq

def a_star(g, h, start, goal):
    pq_list = []  # priority queue to hold cities to explore
    heapq.heappush(pq_list, (0 + h[start], start))  # pushihng start city with f_score (f = g + h)

    visited = {}  #reconstruct the path
    g_val = {city: float('inf') for city in g}  # save the cost of the shortest path to each city
    g_val[start] = 0  #cost to start city is 0

    while pq_list:
        # pop the city with the lowest f_score
        _, this_city = heapq.heappop(pq_list)


        if this_city == goal:
<a name="0"></a><font color="#FF0000"><a href="match235-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

            return reform_path(visited, this_city)

        # explore the neighbors
        for n1, cost in g[this_city]:
            # find the approx g_val
            approx = g_val[this_city] + cost

            # if this pathis better, update it
            if approx &lt; g_val[n1]:
                visited[n1] = this_city
                g_val[n1] = approx

                # find  f_score and add to list
                f_score = approx + h[n1]
                heapq.heappush(pq_list, (f_score, n1))

    return None

#calculate the total distance of the final path
def total_dis(g, path):
    total_distance = 0
</font><a name="1"></a><font color="#00FF00"><a href="match235-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

    for i in range(len(path) - 1):
        this_city = path[i]
        next_city = path[i + 1]
        #cost to move from this_city to next_city
        for n, cost in g[this_city]:
            if n == next_city:
                total_distance += cost
</font>                break
    return total_distance

# build the path
def reform_path(visited, this_city):
    path = []
    while this_city in visited:  # backtracking from goal to start
        path.append(this_city)
        this_city = visited[this_city]
    path.append(this_city)
    path.reverse()  # reverse to get path from start to goal
    return path

def read_input(input1):
    g = {}  # Store the graph as {city: [(neighbor, cost), ...]}
    h = {}  # Store the heuristic values for each city

    with open("/content/sample_data/input1.txt", 'r') as file:
        lines = file.readlines()


    for x in lines:
        blocks = x.split()
        city = blocks[0]  # city name
        h_val = int(blocks[1])  # heuristic value
        n = [(blocks[i], int(blocks[i + 1])) for i in range(2, len(blocks), 2)]  # Neighbors with their costs

        g[city] = n
        h[city] = h_val

    return g, h


# Main program
if __name__ == "__main__":
    input1 = "input.txt"
    g, h = read_input(input1)

    start = input("Enter the start node: ")
    goal = input("Enter the destination: ")


    path = a_star(g, h, start, goal)


    output_input1 = "output.txt"
    with open(output_input1, 'w') as output_file:
        if path:
            total_distance = total_dis(g, path)
            output_file.write(f"Total distance: {total_distance} km\n")
            output_file.write("Path: " + " -&gt; ".join(path))

        else:
            output_file.write(f"NO PATH FOUND")
    print(f"Please Check Output File")</pre>
</body>
</html>
