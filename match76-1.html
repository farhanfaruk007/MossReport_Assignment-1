<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/14/21201398_cse422_14_labassignment1_-_SUBHA_NAJ_SHOWKAT.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/14/21201772_cse422_section14_labassignment1_-_SAYED_AFRIDI.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201772_CSE422_Section14_LabAssignment1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oN-_nwnED4OxGWDWhnadFIIonBH9CaYs
"""

<a name="0"></a><font color="#FF0000"><a href="match76-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_36.gif"/></a>

def a_star_search(start_node, goal_node, graph_data):
    open_nodes = {start_node}
    closed_nodes = set()

    g_costs = {start_node: 0}

    # Estimated total cost (g_cost + heuristic) for each node
    f_costs = {start_node: graph_data[start_node]["h"]}

    parent_nodes = {}

    while open_nodes:
        # Select the node with the lowest f_cost (g_cost + heuristic)
        current_node = min(open_nodes, key=lambda node: f_costs[node])

        # If we reached the goal, reconstruct the path
        if current_node == goal_node:
            path = [current_node]
            while current_node in parent_nodes:
                current_node = parent_nodes[current_node]
                path.append(current_node)
            path.reverse()
            return f_costs[goal_node], path

        open_nodes.remove(current_node)
        closed_nodes.add(current_node)

        for neighbor, edge_cost in graph_data[current_node]["e"].items():
            if neighbor in closed_nodes:
                continue

            tentative_g_cost = g_costs[current_node] + edge_cost

            if neighbor not in open_nodes or tentative_g_cost &lt; g_costs[neighbor]:
</font>                parent_nodes[neighbor] = current_node
                g_costs[neighbor] = tentative_g_cost
                f_costs[neighbor] = g_costs[neighbor] + graph_data[neighbor]["h"]

                open_nodes.add(neighbor)

    return None

# Function to read the graph data from the input file
def load_graph_from_file(file):
    file_path = open(file, 'r')
    graph = {}
<a name="2"></a><font color="#0000FF"><a href="match76-0.html#2" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    for line in file_path.readlines():
        parts = line.split()
        city = parts[0]
        heuristic = int(parts[1])
        neighbors = {}

        for i in range(2, len(parts), 2):
</font>            neighbor = parts[i]
            distance = int(parts[i + 1])
            neighbors[neighbor] = distance

        graph[city] = {"h": heuristic, "e": neighbors}

<a name="1"></a><font color="#00FF00"><a href="match76-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

    return graph

# User input
start_node = input("Enter the start node: ")
goal_node = input("Enter the destination node: ")

graph_data = load_graph_from_file("/content/Input file.txt")

# Run Code
search_result = a_star_search(start_node, goal_node, graph_data)

if search_result is None:
    print("No path exists between the start and destination.")
else:
    total_distance, path_taken = search_result
    print("Optimal Path:", " -&gt; ".join(path_taken))
</font>    print(f"Total Distance: {total_distance}")</pre>
</body>
</html>
