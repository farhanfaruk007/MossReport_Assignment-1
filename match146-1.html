<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/7/21301441_Mohammod_Tasneem_Hasan_CSE422_07_Assignment01_Fall2024_-_Mohammod_Tasneem_Hasan.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/13/21201145_afrida_afaf_assignment01_fall2024_-_AFRIDA_AFAF.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201145_Afrida Afaf_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gYvvPXd97riLcUqU8PClgJi6Dd3ALiYg
"""

import heapq

<a name="1"></a><font color="#00FF00"><a href="match146-0.html#1" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_12.gif"/></a>

class AStarAlgorithm:
    def __init__(self, input_file):
        self.graph, self.heuristic = self.parse_input(input_file)

    def parse_input(self, input_file):
        graph = {}
        heuristic = {}

        with open(input_file, "r") as file:
            for line in file:
                parts = line.strip().split()
</font>                city = parts[0]
                heuristic[city] = int(parts[1])
                neighbors = {}
                for i in range(2, len(parts), 2):
                    neighbors[parts[i]] = int(parts[i + 1])
                graph[city] = neighbors

        return graph, heuristic

    def run_astar(self, start, goal):
        priority_queue = []
        heapq.heappush(priority_queue, (0, start))
<a name="0"></a><font color="#FF0000"><a href="match146-0.html#0" target="0"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_25.gif"/></a>

        parent = {start: None}
        cost = {start: 0}

        while priority_queue:
            _, current_node = heapq.heappop(priority_queue)

            if current_node == goal:
                return parent, cost

            for neighbor, weight in self.graph.get(current_node, {}).items():
                new_cost = cost[current_node] + weight
                if neighbor not in cost or new_cost &lt; cost[neighbor]:
                    cost[neighbor] = new_cost
                    priority = new_cost + self.heuristic.get(neighbor, float('inf'))
                    heapq.heappush(priority_queue, (priority, neighbor))
                    parent[neighbor] = current_node
</font>
        return {}, {}

    def construct_path(self, start, goal, parent, cost):
        if goal not in cost:
            print("NO PATH FOUND")
            return

        path = []
        current = goal
        while current:
            path.append(current)
            current = parent[current]
        path.reverse()

        print(f"Path: {' -&gt; '.join(path)}")
        print(f"Total distance: {cost[goal]} km")

    def find_path(self, start, goal):
        if start not in self.graph or goal not in self.graph:
            print("NO PATH FOUND")
            return

        parent, cost = self.run_astar(start, goal)
        self.construct_path(start, goal, parent, cost)


# Input and execution
input_file = "/content/Input file.txt"
start_node = input("Start node: ").strip()
destination_node = input("Destination: ").strip()

astar = AStarAlgorithm(input_file)
astar.find_path(start_node, destination_node)</pre>
</body>
</html>
