<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/16/21201051_cse422_16_labassignment01_-_SANJANA_ZAMAN.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/16/21201051_cse422_16_labassignment01_-_SANJANA_ZAMAN.py<p></p><pre>
# -*- coding: utf-8 -*-
"""21201051_CSE422_16_LABASSIGNMENT01

<a name="0"></a><font color="#FF0000"><a href="match0-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_98.gif"/></a>

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14EpASbsEtAjb0K4t3dAaVrWgREY5rj0B
"""

class PQueue:
    def __init__(self,size):
        self.queue = []
        self.priority = []
        self.path = []

    def sortqueue(self):
        for idx1 in range(len(self.queue)):
            for idx2 in range(len(self.queue)):
                if self.priority[idx2]&gt;self.priority[idx1] and (self.priority[idx2]!= 0 and self.priority[idx1]!= 0):
                    n = self.queue[idx1]
                    val = self.priority[idx1]
                    p = self.path[idx1]
                    self.queue[idx1]=self.queue[idx2]
                    self.queue[idx2] = n
                    self.priority[idx1] = self.priority[idx2]
                    self.priority[idx2] = val
                    self.path[idx1] = self.path[idx2]
                    self.path[idx2] =  p


    def enqueue(self, n, c, p): #n=node,c=cost and p=path
        self.queue.append(n)
        self.priority.append(c)
        self.path.append(p)
        self.sortqueue()


    def dequeue(self):
        element = (self.queue[0], self.priority[0], self.path[0])
        for m in range(1, len(self.queue)):
            self.queue[m - 1] = self.queue[m]
            self.priority[m-1] = self.priority[m]
            self.path[m-1] = self.path[m]
        del self.queue[-1]
        del self.priority[-1]
        del self.path[-1]
        return element

    def print_queue(self):
        len = len(self.queue)
        for i in range(len):
            print(self.queue[i], end=' ')
        print()
        for j in range(len):
            print(self.priority[j], end=' ')
        print()
        for k in range(len):
            print(self.path[k], end=' ')
        print()

    def empty(self):
        return self.queue[0] == 0




class AStarSearch:
    def __init__(self, f):
        self.file = f
        self.heuristic = {}
        self.graph = {}
        self.element = 0
        with open(f, "r") as file:
            for line in file:
                self.element+=1
        self.Graph()
        self.look(input("Start Node: "), input("Destination: "))
    def Graph(self):
        with open(self.file, "r") as file:
            for i in range(self.element):
                line = file.readline().split()
                self.heuristic[line[0]] = int(line[1])
                Dict= {}
                for j in range(2, len(line)-1,2):
                    Dict[line[j]] = int(line[j+1])
                self.graph[line[0]] = Dict


    def look(self, srt, goal):
        p= PQueue(self.element)
        p.enqueue(srt, 0, srt)

        for _ in range(self.element):
            currentN, currentC, currentP = p.dequeue()

            if currentN!=srt:
                currentC = currentC - self.heuristic[currentN]

            if currentN==goal:
                print(f"Path: {currentP}")
                print(f"Total Distance: {currentC} km")
                return
            for y,z in self.graph[currentN].items():
                p.enqueue(y, currentC+z+self.heuristic[y], currentP+" &gt; "+y )
        print("NO PATH FOUND")


var = AStarSearch("Input file.txt")</font></pre>
</body>
</html>
