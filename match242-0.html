<html>
<head>
<title>C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/1/22101614_shaikh_mohammad_ali_shams_cse422_01_assignment01_fall2024_-_SHAIKH_MOHAMMAD_ALI_SHAMS.py</title>
</head>
<body bgcolor="white">
<hr/>
C:/Users/Farhan_Faruk/Downloads/Lab1_Submission/1/22101614_shaikh_mohammad_ali_shams_cse422_01_assignment01_fall2024_-_SHAIKH_MOHAMMAD_ALI_SHAMS.py<p></p><pre>
# -*- coding: utf-8 -*-
"""22101614_Shaikh_Mohammad_Ali_Shams_CSE422_01_Assignment01_Fall2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-zwZalKqx8hJcg4iJZaLrCYwpqScMCET
"""

#final
<a name="1"></a><font color="#00FF00"><a href="match242-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

import heapq
def load_graph_and_heuristics():
    graph_nodes={}
    H_dist={}
    with open("input.txt",'r') as input_file:
        for line in input_file:
            parts=line.strip().split()
            node=parts[0]
</font>            H_dist[node] = int(parts[1])  # Set the heuristic value
            # Add neighbors and distances to the adjacency list
            neighbors = []
            for i in range(2, len(parts), 2):
              neighbor = parts[i]
              distance = int(parts[i + 1])
<a name="2"></a><font color="#0000FF"><a href="match242-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_10.gif"/></a>

              neighbors.append((neighbor, distance))
            graph_nodes[node] = neighbors
    return graph_nodes, H_dist
def a_star_search(graph, heuristics, start, goal):
    # Priority queue to store nodes with their f-score
    p_queue=[]
    heapq.heappush(p_queue,(0,start))  # Add the start node with f-score 0
    # Dictionary to store the actual cost from start to each node
    actual_cost={start:0}
</font>    # Dictionary to track the parent node for path reconstruction
    parent_node={}
    while p_queue:
        # Pop the node with the lowest f-score
        _, current=heapq.heappop(p_queue)
        # Check if the goal has been reached
        if current==goal:
           # goal to start
          path = [current]
          while current in parent_node:
<a name="0"></a><font color="#FF0000"><a href="match242-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_12.gif"/></a>

             current = parent_node[current]
             path.append(current)
          return path[::-1], actual_cost[goal]
        # each neighbor of the current node
        for neighbor,distance in graph[current]:
            tentative_g_score=actual_cost[current]+distance
            # If a better path to the neighbor is found
            if neighbor not in actual_cost or tentative_g_score&lt;actual_cost[neighbor]:
</font>                actual_cost[neighbor] = tentative_g_score
                f_score = tentative_g_score + heuristics[neighbor]
                heapq.heappush(p_queue, (f_score, neighbor))
                parent_node[neighbor] = current
# Load graph and heuristic data
graph_nodes,H_dist=load_graph_and_heuristics()
# Input start and goal nodes
start=input("Enter the starting point: ").strip()
goal=input("Enter the destination point: ").strip()
# Run A* algorithm
path, total_cost = a_star_search(graph_nodes, H_dist, start, goal)
# Output the result
if path:
    print("Path:"," -&gt; ".join(path))
    print("Total Distance:", total_cost, "km")

else:
    print("No Path Found.")</pre>
</body>
</html>
